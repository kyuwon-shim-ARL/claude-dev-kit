{
  "version": "2.0",
  "last_updated": "2025-08-18",
  "description": "Claude Dev Kit 중앙 프롬프트 저장소 - 텔레그램 claude-ops 검증된 프롬프트 기반",
  "prompts": {
    "기획": {
      "title": "Structured Discovery & Planning Loop",
      "description": "구조화된 탐색-계획 루프를 통한 체계적 프로젝트 기획",
      "text": "🎯 **기획 (Structured Discovery & Planning Loop)**\n\n**📚 컨텍스트 자동 로딩:**\n- project_rules.md 확인 (있으면 읽기)\n- docs/CURRENT/status.md 확인 (있으면 읽기)\n- 이전 세션 TODO 확인\n\n**탐색 단계:**\n- 전체 구조 파악: 현재 시스템 아키텍처와 요구사항 분석\n- As-Is/To-Be/Gap 분석: 현재 상태, 목표 상태, 차이점 식별\n- 이해관계자 요구사항 수집 및 우선순위화\n\n**계획 단계:**\n- MECE 기반 작업분해(WBS): 상호배타적이고 전체포괄적인 업무 구조\n- 우선순위 매트릭스: 중요도와 긴급도 기반 작업 순서 결정\n- 리소스 및 일정 계획 수립\n\n**수렴 단계:**\n- 탐색↔계획 반복 iterative refinement\n- PRD(Product Requirements Document) 완성\n- TodoWrite를 활용한 구조화된 작업 계획 수립\n\n**💾 자동 문서화:**\n- 기획 결과를 docs/CURRENT/planning.md에 저장\n- TodoWrite 내용을 docs/CURRENT/active-todos.md에 동기화\n\n**산출물:** 구체적인 실행 계획과 성공 기준이 포함된 PRD"
    },
    "구현": {
      "title": "Implementation with DRY",
      "description": "DRY 원칙에 따른 체계적 구현",
      "text": "⚡ **구현 (Implementation with DRY)**\n\n**📚 컨텍스트 자동 로딩:**\n- project_rules.md 확인 (있으면 읽기)\n- docs/CURRENT/active-todos.md 확인 (있으면 읽기)\n\n**DRY 원칙 적용:**\n- 기존 코드 검색: Grep, Glob 도구로 유사 기능 탐색\n- 재사용 우선: 기존 라이브러리/모듈/함수 활용\n- 없으면 생성: 새로운 컴포넌트 개발 시 재사용성 고려\n\n**체계적 진행:**\n- TodoWrite 기반 단계별 구현\n- 모듈화된 코드 구조 유지\n- 코딩 컨벤션 준수 (기존 코드 스타일 분석 후 적용)\n\n**품질 보증:**\n- 단위 테스트 작성 및 실행\n- 기본 검증: 문법 체크, 타입 체크, 린트\n- 동작 확인: 핵심 기능 동작 테스트\n\n**💾 자동 문서화:**\n- 구현 진행상황을 docs/CURRENT/implementation.md에 기록\n- TodoWrite 업데이트를 docs/CURRENT/active-todos.md에 반영\n\n**산출물:** 테스트 통과하는 동작 가능한 코드"
    },
    "안정화": {
      "title": "Structural Sustainability Protocol v2.0",
      "description": "구조적 지속가능성 프로토콜을 통한 시스템 안정화",
      "text": "🔧 **안정화 (Structural Sustainability Protocol v2.0)**\n\n**📚 컨텍스트 자동 로딩:**\n- project_rules.md 확인 (있으면 읽기)\n- docs/CURRENT/test-report.md 확인 (이전 테스트 결과)\n\n**패러다임 전환:** 기능 중심 → **구조적 지속가능성** 중심\n\n**6단계 통합 검증 루프:**\n\n1. **Repository Structure Scan**\n   - 전체 파일 분석: 디렉토리 구조, 파일 목적성 검토\n   - 중복/임시 파일 식별 및 정리 방안 수립\n   - 파일 크기 및 복잡도 분석\n\n2. **Structural Optimization**\n   - 디렉토리 정리: 논리적 그룹핑, 계층 구조 최적화\n   - 파일 분류: 목적별, 기능별 체계적 분류\n   - 네이밍 표준화: 일관된 명명 규칙 적용\n\n3. **Dependency Resolution**\n   - Import 수정: 순환 참조 해결, 의존성 최적화\n   - 참조 오류 해결: 깨진 링크, 잘못된 경로 수정\n   - 환경 동기화: requirements, configs 일치성 확인\n\n4. **User-Centric Comprehensive Testing** ⚠️ **Mock 테스트 금지**\n   \n   **4.1 PRD 기반 실제 시나리오 테스트**\n   - 기획 단계에서 정의된 핵심 사용자 스토리를 **실제 데이터**로 검증\n   - Mock이나 가짜 데이터가 아닌 실제 운영 환경 데이터 사용 필수\n   - 각 PRD 요구사항별로 \"실제 사용자가 이 기능을 사용할 때\" 시나리오 실행\n   \n   **4.2 프로젝트 유형별 실제 테스트 실행**\n   - **웹 프로젝트**: Playwright로 실제 브라우저 E2E 테스트 필수\n     - `uv run playwright test` 또는 `npm run test:e2e` 실행\n     - 실제 사용자 클릭, 입력, 네비게이션 시뮬레이션\n     - 크로스 브라우저(Chrome, Firefox, Safari) 호환성 확인\n     - 모바일/데스크톱 반응형 테스트\n   - **API 프로젝트**: 실제 HTTP 요청으로 엔드포인트 검증\n   - **CLI 도구**: 실제 명령어 실행과 파일 시스템 테스트\n   - **데이터 처리**: 실제 데이터셋으로 파이프라인 검증\n   \n   **4.3 End-to-End 워크플로우 검증**\n   - 사용자 진입점부터 최종 목표 달성까지 전체 경로 테스트\n   - 에러 케이스와 예외 상황에서의 시스템 동작 확인\n   - 성능 병목점과 사용자 경험 저하 지점 식별\n   \n   **4.4 정량적 성능 검증 (구체적 수치 필수)**\n   - \"통과했습니다\" 금지 → 반드시 측정값 제시\n   - 웹: 페이지 로딩 시간, First Contentful Paint, Lighthouse 점수\n   - API: 평균 응답시간, 처리량(RPS), 99th percentile 응답시간\n   - 메모리 사용량, CPU 사용률, 동시 사용자 처리 능력\n   - PRD에서 정의한 성능 목표 대비 실제 측정값 비교\n\n5. **Documentation Sync**\n   - CLAUDE.md 반영: 변경사항 문서화\n   - README 업데이트: 사용법, 설치법 최신화\n   - .gitignore 정리: 불필요한 파일 제외 규칙 정비\n\n6. **Quality Assurance**\n   - MECE 분석: 빠진 것은 없는지, 중복은 없는지 확인\n   - 성능 벤치마크: 기준 성능 대비 측정\n   - 정량 평가: 실제 코드 커버리지, 복잡도, 품질 지표\n\n**예방적 관리 트리거:**\n- 루트 20개 파일 이상\n- 임시 파일 5개 이상\n- Import 오류 3개 이상\n→ 자동 안정화 프로세스 실행\n\n**💾 자동 문서화:**\n- 테스트 결과를 docs/CURRENT/test-report.md에 기록\n- 성능 측정값을 구체적 수치와 함께 저장\n\n**산출물:** 실제 사용자 시나리오에서 검증된 지속가능하고 확장 가능한 코드베이스"
    },
    "배포": {
      "title": "Deployment",
      "description": "프로덕션 배포를 위한 최종 검증 및 배포",
      "text": "🚀 **배포 (Deployment)**\n\n**📚 컨텍스트 자동 로딩:**\n- project_rules.md 확인 (있으면 읽기)\n- docs/CURRENT/ 전체 상태 확인\n\n**최종 검증:**\n- 체크리스트 완료 확인: 모든 TODO 완료, 테스트 통과\n- 코드 리뷰: 보안, 성능, 코딩 표준 최종 점검\n- 배포 전 시나리오 테스트: 프로덕션 환경 시뮬레이션\n\n**구조화 커밋:**\n- 의미있는 커밋 메시지: 변경사항의 목적과 영향 명시\n- 원자성 보장: 하나의 논리적 변경사항 = 하나의 커밋\n- 관련 이슈/티켓 링크: 추적가능성 확보\n\n**⚠️ 필수: 원격 배포 실행**\n- **반드시 git push 실행**: 커밋만 하고 끝내지 말고 원격 저장소에 푸시 필수\n- **git push origin main**: 변경사항을 즉시 원격 저장소에 전송\n- **버전 태깅**: semantic versioning (major.minor.patch) 태그 생성 및 푸시\n- **배포 완료 확인**: GitHub 등 원격 저장소에서 변경사항 반영 확인\n\n**배포 후 검증:**\n- 원격 저장소 접속하여 변경사항 반영 확인\n- GitHub Raw URL 등 서비스 엔드포인트 동작 테스트\n- 성능 지표 추적: 응답시간, 처리량, 오류율\n- 롤백 준비: 문제 발생 시 즉시 이전 버전으로 복구\n\n**💡 배포 = 커밋 + 푸시 + 태깅 + 검증의 완전한 과정**\n\n**📦 세션 아카이빙 (자동 실행):**\n- docs/CURRENT/* 내용을 docs/development/sessions/YYYY-MM/session-XXX.md로 아카이브\n- 세션 번호는 해당 월의 순차 번호 (session-001, session-002...)\n- Git commit message에 세션 요약 포함\n- docs/CURRENT/ 디렉토리를 다음 세션을 위해 초기화\n- 다음 세션을 위한 next-session.md 템플릿 생성\n\n**산출물:** 원격 저장소에 반영되어 실제 사용 가능한 프로덕션 서비스 + 완전한 세션 기록"
    },
    "검증": {
      "title": "Deep Verification & Testing",
      "description": "심화 검증 및 테스트를 통한 품질 보증",
      "text": "🔍 **검증 (Deep Verification & Testing)**\n\n**📚 컨텍스트 자동 로딩:**\n- project_rules.md 확인 (있으면 읽기)\n- docs/CURRENT/status.md 확인 (있으면 읽기)\n- 이전 테스트 결과 확인\n\n**1단계: 기획 의도 매트릭스 검증**\n- project_rules.md의 모든 원칙 체크\n- 각 원칙별 실제 구현 상태 매핑\n- 기획 의도 충실도 점수 계산 (0-100)\n- 불일치 항목 구체적 리스트업\n\n**2단계: 다층 시나리오 테스트**\n- Level 1: Happy Path - 기본 성공 경로 테스트\n- Level 2: Edge Cases - 경계값, 예외 상황 처리\n- Level 3: Stress Test - 대용량 데이터, 동시성 테스트\n- Level 4: Error Handling - 의도적 실패 유발 및 복구\n- Level 5: User Journey - 실제 사용자 전체 워크플로우\n\n**3단계: 정량적 성능 프로파일링**\n- 각 명령어/기능별 실행 시간 측정\n- 메모리 사용량 추이 분석\n- 파일 I/O 패턴 및 병목 구간 탐지\n- 네트워크 의존성 및 타임아웃 처리 검증\n- CPU 사용률 및 리소스 효율성 평가\n\n**4단계: 코드 품질 심층 분석**\n- 중복 코드 탐지 (DRY 원칙 위반)\n- 순환 의존성 검사\n- 사용하지 않는 코드/파일 식별\n- 보안 취약점 스캔\n- 테스트 커버리지 측정\n\n**5단계: 문서 일관성 검증**\n- README와 실제 기능 일치 여부\n- CLAUDE.md의 명령어와 실제 설치된 명령어 비교\n- API 문서와 실제 엔드포인트 매칭\n- 주석과 코드 동기화 상태\n\n**6단계: 개선 제안 생성**\n- 발견된 문제별 우선순위 설정\n- 각 문제에 대한 구체적 해결 방안 제시\n- 예상 개선 효과 정량화\n- 즉시 적용 가능한 Quick Win 식별\n\n**💾 자동 문서화:**\n- 검증 결과를 docs/CURRENT/verification-report.md에 저장\n- 개선 사항을 docs/CURRENT/improvement-backlog.md에 기록\n\n**📊 산출물: 종합 검증 리포트 (점수 및 개선안 포함)**"
    },
    "극한검증": {
      "title": "Ultimate Verification with Auto-improvement",
      "description": "자동 반복 개선을 통한 극한의 품질 달성",
      "text": "🚀 **극한검증 (Ultimate Verification with Auto-improvement)**\n\n**📚 컨텍스트 자동 로딩:**\n- project_rules.md 확인 (있으면 읽기)\n- docs/CURRENT/status.md 확인 (있으면 읽기)\n- 이전 검증 이력 분석\n\n**🔄 자동 반복 개선 프로세스**\n\n반복 조건:\n- 최대 반복: 5회\n- 목표 점수: 95/100\n- 수렴 판정: 개선율 < 2%\n- 시간 제한: 10분\n\n**Phase 1: 심화 검증 실행**\n/검증 명령어의 모든 단계 실행:\n1. 기획 의도 매트릭스 검증\n2. 다층 시나리오 테스트 (Level 1-5)\n3. 정량적 성능 프로파일링\n4. 코드 품질 심층 분석\n5. 문서 일관성 검증\n6. 개선 제안 생성\n\n**Phase 2: 자동 개선 적용**\n\n**2.1 즉시 수정 (Automatic Fix)**\n- 코드 포맷팅 오류 → 자동 포맷팅 적용\n- 사용하지 않는 import → 자동 제거\n- 누락된 타입 힌트 → 자동 추가\n- 간단한 린트 오류 → 자동 수정\n- 문서 불일치 → 자동 동기화\n\n**2.2 구조 개선 (Refactoring)**\n- 중복 코드 → 함수/모듈로 추출\n- 긴 함수 → 작은 단위로 분할\n- 복잡한 조건문 → 가독성 개선\n- 매직 넘버 → 상수로 변환\n\n**2.3 성능 최적화 (Optimization)**\n- 비효율적 루프 → 최적화된 알고리즘\n- 불필요한 I/O → 캐싱 적용\n- 동기 처리 → 비동기 전환 (가능시)\n- 메모리 누수 → 자원 정리 코드 추가\n\n**Phase 3: 개선 효과 측정 및 수렴 판정**\n- 점수 변화 측정\n- 개선율 계산\n- 목표 달성 여부 확인\n- 다음 라운드 진행 결정\n\n**💾 자동 문서화:**\n- 각 라운드 결과를 docs/CURRENT/extreme-verification-log.md에 기록\n- 최종 결과를 docs/CURRENT/final-quality-report.md에 저장\n- 적용된 모든 개선 사항 추적\n\n**📊 산출물: 극한 검증 완료 리포트 (최종 품질 인증)**\n\n⚠️ 주의: 모든 자동 수정은 안전한 변경만 적용하며, git diff로 추적 가능"
    }
  }
}