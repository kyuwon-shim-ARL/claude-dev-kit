⚡ **구현 (Test-Driven Implementation)**

**🧪 사전 조건 검증:**
```python
# 실패하는 테스트가 있는지 확인
if not exists('tests/test_*_spec.py'):
    print("❌ 테스트가 없습니다. /기획에서 테스트 설계를 먼저 하세요.")
    exit(1)

# 테스트 실행하여 현재 상태 확인
test_results = run_tests()
if all_tests_pass():
    print("✅ 모든 테스트가 이미 통과합니다. 구현이 완료된 상태입니다.")
    exit(0)
```

**📚 컨텍스트 자동 로딩:**
- tests/test_*_spec.py (실패하는 테스트들)
- docs/CURRENT/active-todos.md (구현 작업 목록)
- project_rules.md (코딩 표준)

**🔴🟢 Red-Green-Refactor 사이클:**

**1단계: RED (테스트 실패 확인)**
```bash
# 현재 실패하는 테스트 표시
pytest tests/test_current_feature.py --tb=short
# Expected: ❌ 3/10 tests passing
```

**2단계: GREEN (최소 코드로 통과)**
- 테스트를 통과시키는 최소한의 코드 작성
- 완벽한 코드보다 동작하는 코드 우선
- 각 테스트 통과 시 실시간 피드백:
  ```
  ✅ test_happy_path: PASSED (1/3)
  ✅ test_edge_case: PASSED (2/3)
  ✅ test_error_handling: PASSED (3/3)
  ```

**3단계: REFACTOR (테스트 유지하며 개선)**
- 모든 테스트가 GREEN 상태 유지
- 코드 중복 제거
- 가독성 향상
- 성능 최적화 (필요시)

**🔍 실시간 테스트 피드백:**
```bash
# 구현 중 자동 실행 (watch mode)
watch -n 2 'pytest tests/test_current_feature.py --tb=line'

# 진행률 표시
[████████░░] 80% - 8/10 tests passing
```

**✅ 완료 조건:**
- 모든 테스트가 GREEN
- Theater Testing 없음 (구체적 assertion 확인)
- Mock 사용률 < 20%
- 코드 커버리지 > 60%

**🚫 Anti-Patterns 자동 감지:**
```python
# 다음 패턴 발견 시 경고
if code_contains("assert result is not None"):
    warn("❌ Theater Testing 감지: 구체적 값 검증 필요")
    
if mock_usage > 0.2:
    warn("❌ Mock 과다 사용: Real 구현 필요")
    
if test_has_no_error_cases():
    warn("⚠️ Error case 누락: 예외 처리 테스트 추가")
```

**💡 DRY 원칙 적용:**
- 기존 코드 검색: 유사 기능 재사용
- 공통 로직 추출: utils/helpers로 분리
- 중복 제거: 함수/클래스로 추상화

**📊 품질 메트릭 실시간 표시:**
```
구현 품질 대시보드:
├─ 테스트 통과율: 10/10 (100%) ✅
├─ Mock 사용률: 5% ✅
├─ 코드 커버리지: 75% ✅
├─ Theater Testing: 0 ✅
└─ 복잡도: Low ✅
```

**💾 자동 문서화:**
- 구현 진행상황을 docs/CURRENT/implementation.md에 기록
- 각 테스트 통과 시점 기록
- 리팩토링 이력 추적

**⚠️ 레거시 모드 (--no-test 플래그):**
"⚠️ 테스트 없는 구현은 기술 부채입니다. 정말 진행하시겠습니까? [y/N]"
- 테스트 없이 구현 (강력히 비권장)
- 나중에 테스트 추가 필요
- 품질 보증 불가

**산출물:** 
- 모든 테스트를 통과하는 동작 코드
- 테스트가 명세 역할을 함
- Mock 최소화된 Real 구현